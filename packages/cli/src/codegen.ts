/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/

import { node, Project, Script, Contract, EventSig } from '@alephium/web3'
import * as prettier from 'prettier'
import path from 'path'
import fs from 'fs'

const oneAlph = `ONE_ALPH`
const header = `/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n/* eslint-disable */\n\n`

function array(str: string, size: number): string {
  const result = Array(size).fill(str).join(', ')
  return `[${result}]`
}

function parseArrayType(tpe: string): string {
  const ignored = '[;]'
  const tokens: string[] = []
  let acc = ''
  for (let index = 0; index < tpe.length; index++) {
    if (!ignored.includes(tpe.charAt(index))) {
      acc = acc + tpe.charAt(index)
    } else if (acc !== '') {
      tokens.push(acc)
      acc = ''
    }
  }
  const baseTsType = toTsType(tokens[0])
  const sizes = tokens.slice(1).map((str) => parseInt(str))
  return sizes.reduce((acc, size) => array(acc, size), baseTsType)
}

function toTsType(ralphType: string): string {
  switch (ralphType) {
    case 'U256':
    case 'I256':
      return 'bigint'
    case 'Bool':
      return 'boolean'
    case 'Address':
    case 'ByteVec':
      return 'HexString'
    default: // array type
      return parseArrayType(ralphType)
  }
}

function formatParameters(fieldsSig: { names: string[]; types: string[] }): string {
  return fieldsSig.names.map((name, idx) => `${name}: ${toTsType(fieldsSig.types[`${idx}`])}`).join(', ')
}

function formatToStringArray(strs: string[]): string {
  return `[${strs.map((str) => `'${str}'`).join(', ')}]`
}

function genCallMethod(contractName: string, functionSig: node.FunctionSig, funcIndex: number): string {
  if (!functionSig.isPublic || functionSig.returnTypes.length === 0) {
    return ''
  }
  const funcName = functionSig.name.charAt(0).toUpperCase() + functionSig.name.slice(1)
  const funcHasArgs = functionSig.paramNames.length > 0
  const params = funcHasArgs
    ? `params: CallContractParams<{${formatParameters({
        names: functionSig.paramNames,
        types: functionSig.paramTypes
      })}}>`
    : `params?: Omit<CallContractParams<{}>, 'args'>`
  const tsReturnTypes = functionSig.returnTypes.map((tpe) => toTsType(tpe))
  const retTypeTemp = tsReturnTypes.length === 1 ? `${tsReturnTypes[0]}` : `[${tsReturnTypes.join(', ')}]`
  const retType = `Omit<CallContractResult, 'returns'> & { returns: ${retTypeTemp} }`
  return `
    async call${funcName}Method(${params}): Promise<${retType}> {
      const txId = params?.txId ?? randomTxId()
      const callParams = ${contractName}.contract.toApiCallContract(
        { ...params, txId: txId, ${funcHasArgs ? '' : 'args: {}'} },
        this.groupIndex,
        this.address,
        ${funcIndex}
      )
      const result = await web3.getCurrentNodeProvider().contracts.postContractsCallContract(callParams)
      const callResult = ${contractName}.contract.fromApiCallContractResult(result, txId, ${funcIndex})
      return {
        ...callResult,
        ${
          tsReturnTypes.length === 1
            ? `returns: callResult.returns[0] as ${retTypeTemp}`
            : `returns: callResult.returns as ${retTypeTemp}`
        }
      }
    }
  `
}

function getInstanceName(contract: Contract): string {
  return `${contract.name}Instance`
}

function genAttach(instanceName: string): string {
  return `
  at(address: string): ${instanceName} {
    return new ${instanceName}(address)
  }
  `
}

function contractTypes(contractName: string): string {
  return `${contractName}Types`
}

function contractFieldType(contract: Contract): string {
  const hasFields = contract.fieldsSig.names.length > 0
  return hasFields ? `${contractTypes(contract.name)}.Fields` : '{}'
}

function genFetchState(contract: Contract): string {
  return `
  async fetchState(): Promise<${contractTypes(contract.name)}.State> {
    return fetchContractState(${contract.name}, this)
  }
  `
}

function getEventType(event: EventSig): string {
  return event.name + 'Event'
}

function genEventType(event: EventSig): string {
  if (event.fieldNames.length === 0) {
    return `export type ${getEventType(event)} = Omit<ContractEvent, 'fields'>`
  }
  const fieldsType = `{${formatParameters({ names: event.fieldNames, types: event.fieldTypes })}}`
  return `export type ${getEventType(event)} = ContractEvent<${fieldsType}>`
}

function genDecodeEvent(contractName: string, event: EventSig, eventIndex: number): string {
  const hasFields = event.fieldNames.length > 0
  const assigns = event.fieldNames
    .map((name, index) => `${name}: fields['${name}'] as ${toTsType(event.fieldTypes[`${index}`])}`)
    .join(', ')
  const eventType = getEventType(event)
  return `
    private decode${eventType}(event: node.ContractEvent): ${contractTypes(contractName)}.${eventType} {
      if (event.eventIndex !== ${eventIndex}) {
        throw new Error('Invalid event index: ' + event.eventIndex + ', expected: ${eventIndex}')
      }
      ${
        hasFields
          ? `const fields = fromApiVals(
              event.fields,
              ${formatToStringArray(event.fieldNames)},
              ${formatToStringArray(event.fieldTypes)}
            )`
          : ''
      }
      return {
        contractAddress: this.address,
        blockHash: event.blockHash,
        txId: event.txId,
        eventIndex: event.eventIndex,
        name: '${event.name}',
        ${hasFields ? `fields: {${assigns}}` : ''}
      }
    }
  `
}

function genSubscribeSystemEvent(event: SystemEvent): string {
  return `
    subscribe${event.eventSig.name}Event(options: SubscribeOptions<${event.eventType}>, fromCount?: number): EventSubscription {
      return subscribeEventsFromContract(
        options,
        this.address,
        ${event.eventIndex},
        (event) => {
          return { ...${event.decodeFunc}(event), contractAddress: this.address }
        },
        fromCount
      )
    }
  `
}

function genSubscribeEvent(contractName: string, event: EventSig, eventIndex: number): string {
  const eventType = getEventType(event)
  const scopedEventType = `${contractTypes(contractName)}.${eventType}`
  return `
    ${genDecodeEvent(contractName, event, eventIndex)}

    subscribe${eventType}(options: SubscribeOptions<${scopedEventType}>, fromCount?: number): EventSubscription {
      return subscribeEventsFromContract(
        options,
        this.address,
        ${eventIndex},
        (event) => this.decode${eventType}(event),
        fromCount
      )
    }
  `
}

function genSubscribeAllEvents(contract: Contract, systemEvents: SystemEvent[]): string {
  const contractEventTypes = contract.eventsSig.map((e) => `${contractTypes(contract.name)}.${getEventType(e)}`)
  const systemEventTypes = systemEvents.map((e) => e.eventType)
  const eventTypes = contractEventTypes.concat(systemEventTypes).join(' | ')
  const contractEventCases = contract.eventsSig.map((event, index) => {
    return `
      case ${index}: {
        return options.messageCallback(this.decode${getEventType(event)}(event))
      }
    `
  })
  const systemEventCases = systemEvents.map((e) => {
    return `
      case ${e.eventIndex}: {
        return options.messageCallback({ ...${e.decodeFunc}(event), contractAddress: this.address })
      }
    `
  })
  const cases = contractEventCases.concat(systemEventCases).join('\n')
  return `
    subscribeEvents(options: SubscribeOptions<${eventTypes}>, fromCount?: number): EventSubscription {
      const messageCallback = (event: node.ContractEvent): Promise<void> => {
        switch (event.eventIndex) {
          ${cases}
          default:
            throw new Error('Invalid event index: ' + event.eventIndex)
        }
      }
      const errorCallback = (err: any, subscription: Subscription<node.ContractEvent>): Promise<void> => {
        return options.errorCallback(err, subscription as unknown as Subscription<${eventTypes}>)
      }
      const opt: SubscribeOptions<node.ContractEvent> = {
        pollingInterval: options.pollingInterval,
        messageCallback: messageCallback,
        errorCallback: errorCallback
      }
      return subscribeToEvents(opt, this.address, fromCount)
    }
  `
}

function genContractStateType(contract: Contract): string {
  if (contract.fieldsSig.names.length === 0) {
    return `export type State = Omit<ContractState<any>, 'fields'>`
  }
  return `
    export type Fields = {
      ${formatParameters(contract.fieldsSig)}
    }

    export type State = ContractState<Fields>
  `
}

function getParamsFromFieldsSig(fieldsSig: node.FieldsSig, tpe: string): string {
  return fieldsSig.names.length > 0 ? `initFields: ${tpe}, ` : ''
}

function getInitialFieldsFromFieldsSig(fieldsSig: node.FieldsSig): string {
  return fieldsSig.names.length > 0 ? 'initFields' : '{}'
}

function genTestMethod(contract: Contract, functionSig: node.FunctionSig, index: number): string {
  const funcName = functionSig.name.charAt(0).toUpperCase() + functionSig.name.slice(1)
  const funcHasArgs = functionSig.paramNames.length > 0
  const contractHasFields = contract.fieldsSig.names.length > 0
  const argsType = funcHasArgs
    ? `{${formatParameters({ names: functionSig.paramNames, types: functionSig.paramTypes })}}`
    : 'never'
  const fieldsType = contractHasFields ? `${contractFieldType(contract)}` : 'never'
  const params =
    funcHasArgs && contractHasFields
      ? `params: TestContractParams<${fieldsType}, ${argsType}>`
      : funcHasArgs
      ? `params: Omit<TestContractParams<${fieldsType}, ${argsType}>, 'initialFields'>`
      : contractHasFields
      ? `params: Omit<TestContractParams<${fieldsType}, ${argsType}>, 'testArgs'>`
      : `params?: Omit<TestContractParams<${fieldsType}, ${argsType}>, 'testArgs' | 'initialFields'>`
  const tsReturnTypes = functionSig.returnTypes.map((tpe) => toTsType(tpe))
  const retType =
    tsReturnTypes.length === 0
      ? `TestContractResult<null>`
      : tsReturnTypes.length === 1
      ? `TestContractResult<${tsReturnTypes[0]}>`
      : `TestContractResult<[${tsReturnTypes.join(', ')}]>`
  const callParams = funcHasArgs || contractHasFields ? 'params' : 'params === undefined ? {} : params'
  return `
    async test${funcName}Method(${params}): Promise<${retType}> {
      return testMethod(this, "${functionSig.name}", ${callParams})
    }
  `
}

type SystemEvent = {
  eventSig: EventSig
  eventIndex: number
  eventType: string
  decodeFunc: string
}

function genContract(contract: Contract, artifactRelativePath: string): string {
  const projectArtifact = Project.currentProject.projectArtifact
  const contractInfo = projectArtifact.infos.get(contract.name)
  if (contractInfo === undefined) {
    throw new Error(`Contract info does not exist: ${contract.name}`)
  }
  const systemEvents: SystemEvent[] = [
    {
      eventSig: Contract.ContractCreatedEvent,
      eventIndex: Contract.ContractCreatedEventIndex,
      eventType: 'ContractCreatedEvent',
      decodeFunc: 'decodeContractCreatedEvent'
    },
    {
      eventSig: Contract.ContractDestroyedEvent,
      eventIndex: Contract.ContractDestroyedEventIndex,
      eventType: 'ContractDestroyedEvent',
      decodeFunc: 'decodeContractDestroyedEvent'
    }
  ]
  const source = `
    ${header}

    import {
      web3, Address, Contract, ContractState, node, binToHex, TestContractResult, Asset, HexString,
      ContractFactory, contractIdFromAddress, ONE_ALPH, groupOfAddress, fromApiVals, subscribeToEvents,
      SubscribeOptions, Subscription, EventSubscription, randomTxId, CallContractParams, CallContractResult,
      TestContractParams, ContractEvent, subscribeEventsFromContract, testMethod, fetchContractState, decodeContractCreatedEvent,
      decodeContractDestroyedEvent, ContractCreatedEvent, ContractDestroyedEvent
    } from '@alephium/web3'
    import { default as ${contract.name}ContractJson } from '../${artifactRelativePath}'

    export namespace ${contract.name}Types {
      ${genContractStateType(contract)}
      ${contract.eventsSig.map((e) => genEventType(e)).join('\n')}
    }

    class Factory extends ContractFactory<${contract.name}Instance, ${contractFieldType(contract)}> {
      ${genAttach(getInstanceName(contract))}
      ${contract.functions.map((f, index) => genTestMethod(contract, f, index)).join('\n')}
    }

    export const ${contract.name} = new Factory(Contract.fromJson(
      ${contract.name}ContractJson,
      '${contractInfo.bytecodeDebugPatch}',
      '${contractInfo.codeHashDebug}',
    ))

    export class ${contract.name}Instance {
      readonly address: Address
      readonly contractId: string
      readonly groupIndex: number

      constructor(
        address: Address,
      ) {
        this.address = address
        this.contractId = binToHex(contractIdFromAddress(address));
        this.groupIndex = groupOfAddress(address);
      }

      ${genFetchState(contract)}
      ${systemEvents.map((e) => genSubscribeSystemEvent(e)).join('\n')}
      ${contract.eventsSig.map((e, index) => genSubscribeEvent(contract.name, e, index)).join('\n')}
      ${genSubscribeAllEvents(contract, systemEvents)}
      ${contract.functions.map((f, index) => genCallMethod(contract.name, f, index)).join('\n')}
    }
`
  return prettier.format(source, { parser: 'typescript' })
}

function genScript(script: Script): string {
  console.log(`Generating code for script ${script.name}`)
  const usePreapprovedAssets = script.functions[0].usePreapprovedAssets
  const fieldsType = script.fieldsSig.names.length > 0 ? `{${formatParameters(script.fieldsSig)}}` : '{}'
  const paramsType = usePreapprovedAssets
    ? `ExecuteScriptParams<${fieldsType}>`
    : `Omit<ExecuteScriptParams<${fieldsType}>, 'attoAlphAmount' | 'tokens'>`
  return `
    export namespace ${script.name} {
      export async function execute(signer: SignerProvider, params: ${paramsType}): Promise<ExecuteScriptResult> {
        const signerParams = await script.txParamsForExecution(signer, params)
        return await signer.signAndSubmitExecuteScriptTx(signerParams)
      }

      export const script = Script.fromJson(${script.name}ScriptJson)
    }
  `
}

function genScripts(outDir: string, artifactDir: string, exports: string[]) {
  exports.push('./scripts')
  const scriptPath = path.join(outDir, 'scripts.ts')
  const scripts = Array.from(Project.currentProject.scripts.values())
  const importArtifacts = Array.from(scripts)
    .map((s) => {
      const artifactPath = s.sourceInfo.getArtifactPath(artifactDir)
      const artifactRelativePath = path.relative(artifactDir, artifactPath)
      return `import { default as ${s.artifact.name}ScriptJson } from '../${artifactRelativePath}'`
    })
    .join('\n')
  const scriptsSource = scripts.map((s) => genScript(s.artifact)).join('\n')
  const source = `
    ${header}

    import {
      ExecuteScriptParams,
      ExecuteScriptResult,
      Script,
      SignerProvider,
      HexString
    } from '@alephium/web3'
    ${importArtifacts}

    ${scriptsSource}
  `
  const formatted = prettier.format(source, { parser: 'typescript' })
  fs.writeFileSync(scriptPath, formatted, 'utf8')
}

function genIndexTs(outDir: string, exports: string[]) {
  const indexPath = path.join(outDir, 'index.ts')
  const exportStatements = exports.map((e) => `export * from "${e}"`).join('\n')
  const source = prettier.format(header + exportStatements, { parser: 'typescript' })
  fs.writeFileSync(indexPath, source, 'utf8')
}

function genContracts(outDir: string, artifactDir: string, exports: string[]) {
  Array.from(Project.currentProject.contracts.values()).forEach((c) => {
    console.log(`Generating code for contract ${c.artifact.name}`)
    exports.push(`./${c.artifact.name}`)
    const filename = `${c.artifact.name}.ts`
    const sourcePath = path.join(outDir, filename)
    const artifactPath = c.sourceInfo.getArtifactPath(artifactDir)
    const artifactRelativePath = path.relative(artifactDir, artifactPath)
    const sourceCode = genContract(c.artifact, artifactRelativePath)
    fs.writeFileSync(sourcePath, sourceCode, 'utf8')
  })
}

export function codegen(artifactDir: string) {
  const outDirTemp = path.join(artifactDir, 'ts')
  const outDir = path.isAbsolute(outDirTemp) ? outDirTemp : path.resolve(outDirTemp)
  if (!fs.existsSync(outDir)) {
    fs.mkdirSync(outDir, { recursive: true })
  }

  const exports: string[] = []
  try {
    genContracts(outDir, artifactDir, exports)
    genScripts(outDir, artifactDir, exports)
    genIndexTs(outDir, exports)
  } catch (error) {
    console.log(`Failed to generate code: ${error}`)
  }
}
